# yaml-language-server: $schema=https://raw.githubusercontent.com/martinring/tmlanguage/master/tmlanguage.json
---
name: Lipi
scopeName: source.lipi

patterns:
  - include: '#comment'
  - include: '#annotation'
  - include: '#atom'
  - include: '#sexp'

repository:
  # --------
  # COMMENTS
  # --------

  # A span of text ignored by the reader (the compiler will still keep them in
  # the syntax tree).
  comment:
    patterns:
      - include: '#comment-shebang'
      - include: '#comment-line'
      - include: '#comment-block'

  # The shebang interpreter directive - it must begin at the first column of
  # the line. It should also appear in the very first line of the file, but we
  # don't want to enforce that here.
  comment-shebang:
    name: comment.line.lipi
    begin: ^#!
    end: \n

  # A line comment - everything from the semicolon (`;`) to the end of the line
  # is ignored.
  comment-line:
    name: comment.line.lipi
    begin: ;
    end: \n

  # A block comment - an s-expression preceded by `#_` and allows nested block
  # comments. Block comments are true comments and thus whatever is inside is
  # not validated by the compiler.
  comment-block:
    name: comment.block.lipi
    begin: '#_(%*)\('
    end: \)\1
    patterns:
      - include: '#comment-block'

  # -----------
  # ANNOTATIONS
  # -----------

  # Metadata to annotate the syntax tree itself.
  annotation:
    patterns:
      - include: '#annotation-identifier'
      - include: '#annotation-parenthesis'

  # A nested s-expression in an annotation.
  annotation-nested:
    patterns:
      - begin: \(
        end: \)
        patterns:
          - include: '#annotation-nested'

  # A caret (`^`) followed by a valid identifier.
  annotation-identifier:
    name: entity.name.type.lipi
    match: (?<=^|[,\s\(\[\{])\^(?:[[:alpha:]!$?*\-=_+<>.?][\/[:alnum:]!$?*\-=_+<>.?]*)(?=$|[,\s\)\]\}])

  # A caret (`^`) followed by an s-expression.
  annotation-parenthesis:
    name: entity.name.type.lipi
    begin: (?<=^|[\[\{\s])\^\(
    end: \)
    patterns:
      - include: '#annotation-nested'

  # -----
  # ATOMS
  # -----

  # The smallest divisible element in a Lipi program.
  atom:
    patterns:
      - include: '#atom-keyword'
      - include: '#atom-number'
      - include: '#atom-character'
      - include: '#atom-string'

  # A symbolic identifier that evaluates to itself.
  atom-keyword:
    name: entity.name.tag.lipi
    # The syntax highlighter should be as lenient as possible, so we won't
    # validate the characters of the keyword here. That should be the
    # responsibility of the compiler and linter. As long as the keyword starts
    # with a certain symbol or any kind of letter from any language, we'll match
    # until a comma, space or a closing parenthesis/bracket/brace.
    match: (?<=^|[,\s\(\[\{]):{1,2}[\p{L}\-=+*'?!<>_][^,\s\)\]\}]*

  # A numeric literal representing an integer or float.
  atom-number:
    patterns:
      # A number literal with custom base.
      # TODO: Should we accept the decimal point?
      - name: constant.numeric.lipi
        match: (?<=^|[,\s\(\[\{])~?(#(?:3[0-6]|[12][0-9]|[2-9])')([0-9A-Za-z_]+)('?[Ee](?:-|\+?)[[:digit:]]+)?(?=$|[,\s\)\]\}])

      # A regular number literal in the default decimal base.
      - name: constant.numeric.lipi
        match: (?<=^|[,\s\(\[\{])~?[[:digit:]][[:digit:]_]*(?:\.[[:digit:]_]+)?('?[Ee](?:-|\+?)[[:digit:]]+)?(?=$|[,\s\)\]\}])

  # A character literal.
  atom-character:
    match: (?<=^|[,\s(\[\{])\\(?:(\\u\{[^\}]*\})|(\\[^,\s\)\]\}]+)|[^,\s\)\]\}]*)
    captures:
      '0': { name: string.quoted.single.lipi }
      '1': { name: constant.character.escape.lipi }
      '2': { name: constant.character.escape.lipi }

  # A string literal.
  atom-string:
    patterns:
      - include: '#atom-string-triple-raw'
      - include: '#atom-string-triple-static'
      - include: '#atom-string-double-raw'
      - include: '#atom-string-double-static'

  # A sequence of characters to represent a escape literal in a string literal.
  atom-string-escape:
    name: constant.character.escape.lipi
    match: \\((u\{[^\}]*\})|.)

  # A string literal surrounded by THREE pairs of quotation marks (`"`) and
  # preceded by the pound sign (`#`). Escape sequences are ignored.
  atom-string-triple-raw:
    name: string.quoted.triple.lipi
    begin: '#"{3}'
    end: '"{3}'

  # A string literal surrounded by THREE pairs of quotation marks (`"`). It
  # accepts escape sequences.
  atom-string-triple-static:
    name: string.quoted.triple.lipi
    begin: '"{3}'
    end: '"{3}'
    patterns:
      - include: '#atom-string-escape'

  # A string literal surrounded by ONE pair of quotation marks (`"`) and
  # preceded by the pound sign (`#`). Escape sequences are ignored.
  atom-string-double-raw:
    name: string.quoted.double.lipi
    begin: '#"{1}'
    end: '"{1}'

  # A string literal surrounded by ONE pair of quotation marks (`"`). It accepts
  # escape sequences.
  atom-string-double-static:
    name: string.quoted.double.lipi
    begin: '"{1}'
    end: '"{1}'
    patterns:
      - include: '#atom-string-escape'

  # An s-expression where the first atom may be a function or a builtin keyword.
  sexp:
    begin: (?<!')\(\s*(?!:)(?:(->{1,2}|and|case|cond|declare|def[\.~!%^&*\-=_+|\\:'<>\/?\p{L}\p{Sm}\p{Sc}\p{M}\p{N}]*|derives|do|forall|fn|if(?:-let)?|let|modulus|or|range|sig|the|(?:import|use|using)|(?:first|last)|(?:either|record|union))(?=[\s\)])|(@?[\.~!^&*\-=_+|\\:'<>\/?\p{L}\p{Sm}\p{Sc}][\.~!%^&*\-=_+|\\:'<>\/?\p{L}\p{Sm}\p{Sc}\p{M}\p{N}]*))
    end: \)
    beginCaptures:
      '1': { name: 'storage.type.lipi keyword.other.lipi' }
      '2': { name: entity.name.function.lipi }
    patterns:
      - include: $self
